\documentclass{article}

\usepackage{amsthm}
\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{fullpage}
\usepackage[usenames]{color}
\usepackage{hyperref}
  \hypersetup{
    colorlinks = true,
    urlcolor = blue,       % color of external links using \href
    linkcolor= blue,       % color of internal links 
    citecolor= blue,       % color of links to bibliography
    filecolor= blue,        % color of file links
    }
    
\usepackage{listings}

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\lstset{frame=tb,
  language=haskell,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\small\ttfamily},
  numbers=none,
  numberstyle=\tiny\color{gray},
  keywordstyle=\color{blue},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  breaklines=true,
  breakatwhitespace=true,
  tabsize=3
}

\theoremstyle{theorem} 
   \newtheorem{theorem}{Theorem}[section]
   \newtheorem{corollary}[theorem]{Corollary}
   \newtheorem{lemma}[theorem]{Lemma}
   \newtheorem{proposition}[theorem]{Proposition}
\theoremstyle{definition}
   \newtheorem{definition}[theorem]{Definition}
   \newtheorem{example}[theorem]{Example}
\theoremstyle{remark}    
  \newtheorem{remark}[theorem]{Remark}


\title{CPSC-354 Report}
\author{Jackson Goldberg  \\ Chapman University}

\date{\today}

\begin{document}

\maketitle

\begin{abstract}
My Report.  
\end{abstract}

\tableofcontents

\section{Introduction}\label{intro}
Hi there. My name is Jackson Goldberg. I am a senior here at chapman University and I am taking programming languages. I like playing chess. Enjoy reading my report.

\section{Homework}\label{homework}

\subsection{Week 1}

\\Assignment: The aim of this homework is to familiarize yourself with LaTeX. Add your program (one is enough) to report.tex \
and explain in detail how it executes on a sample input such as gcd(9,33)

\\I have added my program into this github repo. It can be found \href{https://github.com/jacgoldberg/Programming-Lang/blob/main/Euclid.py}{here}.
\\It is a simple python program that loops infinatly until subtracting the first and second values from their counterpart until they are equal.
\\Once they are equal then the program prints the results and terminates. You can run in python and it will take in two numbers from the command line.
\\I ran it with python 3 and manually input 9 and 33 yeilding the answer 3.

\subsection{Week 2}
This week we were tasked with creating simple recursive programs in huskall. These are my solutions for all of the assigned functions. These functions can also be found in a huskell
file titled \href{https://github.com/jacgoldberg/Programming-Lang/blob/main/Main.hs}{"Main.hs"}..
\begin{lstlisting}
  -- Takes a list of char and returns a list of char. This works by assinging the element at odd positional values of a list into an empty list using the zip function which is what it returns.
  select_evens :: [[a]] -> [[a]]
  select_evens xs = [x | (x,i) <- zip xs [0..], odd i]

  -- Example:
  select_evens ["a","b","c","d","e"] =
              [] : (select_evens["b","c","d","e]) = 
           ["b"] : (select_evens ["c","d","e"]) = 
           ["b"] : (select_evens ["d","e"]) = 
           ["b","d"] : (select_evens ["e"])
           ["b","d"] : (select_evens []) =
           ["b","d"]

\end{lstlisting}
I referenced \href{https://stackoverflow.com/questions/49741305/how-to-pick-elements-in-even-index-and-odd-index}{this}.
\begin{lstlisting}
  -- Same logic as above just assignes based on even possition.
  select_odds :: [[a]] -> [[a]]
  select_odds xs = [x | (x,i) <- zip xs [0..], even i]

  -- Example:
  select_odds ["a","b","c","d","e"] = 
           ["a"] : (select_odds["b","c","d","e]) = 
           ["a"] : (select_odds ["c","d","e"]) = 
       ["a","c"] : (select_odds ["d","e"]) = 
       ["a","c"] : (select_odds ["e"])
  ["a","c", "e"] : (select_odds []) =
  ["a","c", "e"]
\end{lstlisting}
\begin{lstlisting}
  -- Uses the filter to function to create a list of all matching elements to the ones provided.
     If the length is greater then 0 the its a member.
  member :: Int -> [Int] -> IO Bool
  member x li= do
    let xs = filter(== x) li
    if length xs == 0
        then 
            return (False)
        else do
            return(True)
    
  -- Example: 
  member 2 [5,2,6] =
  1 = filter(== 2) li
  if length xs == 0
        else do
          return(True)
  True
\end{lstlisting}
\begin{lstlisting}
  -- Uses ++ to concatinate lists.
  append :: [Int] -> [Int] -> [Int]
  append l1 l2 = l1 ++ l2 

  --Example:
  append [1,2] [3,4,5] = 
    [1,2] ++ [3,4,5] =
  [1,2,3,4,5]
\end{lstlisting}
\begin{lstlisting}
  -- Recursively assigns element to back of new list, creating a reverse list.
  revert :: [Int] -> [Int]
  revert [] = []
  revert (x:xs) = revert xs ++ [x]

  --Example:
  revert [1,2,3] = 
     [3]: revert[1,2] =
   [3,2]: revert[1] =
   [3,2,1]
\end{lstlisting}
\begin{lstlisting}
  -- Compares two strings using <=.
  less_equal :: [Int] -> [Int] -> IO Bool
  less_equal l1 l2 = do
      if last l1 <= last l2
          then 
              return (True)
          else do
               return (False)
  --Example:
  less_equal [1,2,3] [2,3,2] = 
  3 > 2
  False
\end{lstlisting}

\subsection{Week 3}

This week we were tasked with finishing the hanoi file supplied to us. The full file can be found 
in \href {https://github.com/jacgoldberg/Programming-Lang/blob/main/Hanoi.txt}{Hanoi.txt}.
Hanoi is used 31 times in the file. 
You can express this as formula because it doesn't matter the starting blocks since the process will always be the exact same.
you will always need to reduce to the highest block so the number is nonconsiquental. There are many cool visuals of this online which show what is looks like using a graphical interpritation. There is a simple break down for however many N you have. 
\\ The equation I came up with is H(n) = (2^n-1)-1

\subsection{Week 4}
This week we worked with context free grammers and parse trees. Part one can be found \href {https://github.com/jacgoldberg/Programming-Lang/blob/main/Note%20Sep%2025%2C%202022.pdf}{here}, part 2 can be found 
\href {https://github.com/jacgoldberg/Programming-Lang/blob/main/Note%20Sep%2025%2C%202022%20(2).pdf} {here}. 

\subsection{Week 5}
This week we are doing a lot of lambda calc stuff with abstract syntax trees.

Using the parser to generate linearized abstract syntax trees:
\begin{lstlisting}
  Input:
\ x . x a

[Abstract Syntax]

Prog (EApp (EAbs (Id "x") (EVar (Id "x"))) (EVar (Id "a")))

 Output:
a 
\end{lstlisting}
\begin{lstlisting}
  Input:
  \ x . x a
  
  [Abstract Syntax]
  
  Prog (EAbs (Id "x") (EApp (EVar (Id "x")) (EVar (Id "a"))))
  
   Output:
  \ x . x a
\end{lstlisting}
\begin{lstlisting}
  Input:
  \ x . \ y . x a b
  
  [Abstract Syntax]
  
  Prog (EApp (EApp (EAbs (Id "x") (EAbs (Id "y") (EVar (Id "x")))) (EVar (Id "a"))) (EVar (Id "b")))
  
   Output:
  a
\end{lstlisting}
\begin{lstlisting}
  Input:
  \ x . \ y . y a b
  
  [Abstract Syntax]
  
  Prog (EApp (EApp (EAbs (Id "x") (EAbs (Id "y") (EVar (Id "y")))) (EVar (Id "a"))) (EVar (Id "b")))
  
   Output:
  b
\end{lstlisting}
\begin{lstlisting}
  Input:
  \ x . \ y . x a b c
  
  [Abstract Syntax]
  
  Prog (EApp (EApp (EApp (EAbs (Id "x") (EAbs (Id "y") (EVar (Id "x")))) (EVar (Id "a"))) (EVar (Id "b"))) (EVar (Id "c")))
  
   Output:
  a c
\end{lstlisting}
\begin{lstlisting}
  Input:
  \ x . \ y . y a b c
  
  [Abstract Syntax]
  
  Prog (EApp (EApp (EApp (EAbs (Id "x") (EAbs (Id "y") (EVar (Id "y")))) (EVar (Id "a"))) (EVar (Id "b"))) (EVar (Id "c")))
  
   Output:
  b c
\end{lstlisting}
\begin{lstlisting}
  Input:
  \ x . \ y . x a (b c)
  
  [Abstract Syntax]
  
  Prog (EApp (EApp (EAbs (Id "x") (EAbs (Id "y") (EVar (Id "x")))) (EVar (Id "a"))) (EApp (EVar (Id "b")) (EVar (Id "c"))))
  
   Output:
  a
\end{lstlisting}
\begin{lstlisting}
  Input:
  \ x . \ y . y a (b c)
  
  [Abstract Syntax]
  
  Prog (EApp (EApp (EAbs (Id "x") (EAbs (Id "y") (EVar (Id "y")))) (EVar (Id "a"))) (EApp (EVar (Id "b")) (EVar (Id "c"))))
  
   Output:
  b c
\end{lstlisting}
\begin{lstlisting}
  Input:
  \ x . \ y . x (a b) c
  
  [Abstract Syntax]
  
  Prog (EApp (EApp (EAbs (Id "x") (EAbs (Id "y") (EVar (Id "x")))) (EApp (EVar (Id "a")) (EVar (Id "b")))) (EVar (Id "c")))
  
   Output:
  a b
\end{lstlisting}
\begin{lstlisting}
  Input:
  \ x . \ y . y (a b) c
  
  [Abstract Syntax]
  
  Prog (EApp (EApp (EAbs (Id "x") (EAbs (Id "y") (EVar (Id "y")))) (EApp (EVar (Id "a")) (EVar (Id "b")))) (EVar (Id "c")))
  
   Output:
  c
\end{lstlisting}
\begin{lstlisting}
  Input:
  \ x . \ y . x (a b c)
  
  [Abstract Syntax]
  
  Prog (EApp (EAbs (Id "x") (EAbs (Id "y") (EVar (Id "x")))) (EApp (EApp (EVar (Id "a")) (EVar (Id "b"))) (EVar (Id "c"))))
  
   Output:
  \ yx0 . a b c
\end{lstlisting}
\begin{lstlisting}
  Input:
  \ x . \ y . y (a b c)
  
  [Abstract Syntax]
  
  Prog (EApp (EAbs (Id "x") (EAbs (Id "y") (EVar (Id "y")))) (EApp (EApp (EVar (Id "a")) (EVar (Id "b"))) (EVar (Id "c"))))
  
   Output:
  \ yy0 . yy0
\end{lstlisting}

Evaluate using pen-and-paper the following expressions:
\begin{lstlisting}
(\x.M) N
N = argument
M = function operation

(\x.x) a = a
\x.x a = \x.x a â€” cannot be reduced further because there are no parentheses
(\x.\y.x) a b = (\x.(\y.x) a) b
                   = (\x.x) a
                   = a
(\x.\y.y) a b = (\x.(\y.y) a) b
                   = (\y.y) b
                   = b
(\x.\y.x) a b c = ((\x.(\y.x) a) b) c
                      = ((\y.a) b) c
                      = (\y.a) b c
                      = a c
(\x.\y.y) a b c = ((\x.(\y.y) a) b) c
                      = ((\y.y) b) c
                      = b c
(\x.\y.x) a (b c) = ((\x.(\y.x)) a) (b c)
                         = (\y.a) (b c)
                         = a
(\x.\y.y) a (b c) = ((\x.(\y.y)) a) (b c)
                         = (\y.y) (b c)
                         = b c
(\x.\y.x) (a b) c = ((\x.(\y.x)) (a b)) c
                         = (\y. a b) c
                         = a b
(\x.\y.y) (a b) c = ((\x.(\y.y)) (a b)) c
                         = (\y.y) c
                         = c
(\x.\y.x) (a b c) = (\x.(\y.x)) (a b c)
                         = (\y. a b c)
(\x.\y.y) (a b c) = (\x.(\y.y)) (a b c)
                         = (\y.y)
\end{lstlisting}

\subsection{Week 6}

This week for homework we did lambda calc beta reduction on exponentiation. The file containing my solution can be founnd in week6.hs \href{https://github.com/jacgoldberg/Programming-Lang/blob/main/week6.hs}{Here} (Has .hs for sake of parentheses convienience).

\subsection{Week 7}
\\Line 5: e1 and e2 are being bound by the = and the scope is until line 7
\\Line 6: i and e3 are being bound by the -> and the scope goes until line 6
\\Line 7: e3 is being bound by -> and the scope is line 7
\\Line 8: x is bound by = and the scope is line 8
\\Line 18: id s id1 e1 are all bound by = and the scope is to the end of line 22
\\line 20: f is bound by = and the scope goes until the end of line 22
\\line 21: e2 is bound by = and the scope goes until the end of line 22
\\The Rest of this weeks homework can be found \href{https://github.com/jacgoldberg/Programming-Lang/blob/main/Note%20Oct%2019%2C%202022.pdf}{here}.

\subsection{Week 8}
\\The ARS does not terminate because lines 3 and 4 are a loop.
\\a is a normal form of aa and b is a normal form of bb
\\No because by definition lines 3 and 4 are infinatly reducing into it's self so you would need to modifty the equivilance in order for the ars to achive normal forms. If you removed lines 3 or 4 the ARS would have normal forms.
\\The normal forms provide termination, this is essentailly like a base case. The two functions would be:
\\F(aa) = a;
\\F(bb) = b;

\subsection{Week 9}
\\1) The deadlines for my project:
\\a. The first deadline November 20th, I will have a writen guild on the rust language breaking down the language.
\\b. The second deadline Novemeber 27th,  I will have a scripted server in rust to show the backend capabilities.
\\c. The third deadline December 4th, I will have both a Rust server and a C server and compare and contrast the differences.
\\2) The assignment
\\This week for our assignment we were asked to evaluate the ARS found in "Homework 9" on canvas. We were tasked with finding the function which corsponds with the set off
rules very similar to a puzzle. One of the first things I noticed is that there were only 3 normal forms: the empty string (""), a, and b. I also noticed there were not equivilance cases, such that
a can be equal to b and so on. With that in mind I set a=1, b=2, and c=3 with the empty string equal to 0 (""=0). From this I could see that the only normal forms were 1 and 2. Given that I knew this ARS couldn't be 
calculating something like addition, subtraction, or multiplication. I first attempted division. However there was not a case in which the answer could be zero with natural numbers. 
I eventually landed on Mod being the most likely answer since given the normal forms it is a function that given the right donominator can yeild 0, 1, and 2 as the only answers. I then checked it against many examples of combinations of a, b, and c.
I found that it was not consistant if the exact string was converted to a number but I did figure out that if you add the numbers together instead of directly translating them that you do end up getting only the remainers 0, 1, and 2 when you divide by 4.
Therefor my answer to the puzzle is that this ARS is the ruleset for SUM of any combination (a,b,c) MOD 4.

\subsection{Week 10}
The homework can be found \href{https://github.com/jacgoldberg/Programming-Lang/blob/main/homework10.txt}{here}.

\subsection{Week 11}
\\My Question:
\\I asked this question in class but since I saw that it wasn't added to the list of questions I thought I would still post it:

\\"What can a DSL not do?"

\\Essentially I am asking what are the limitations of a DSL since they are inherently going to be more restricted then an object oriented programming language given their nature. Is this solution given those limitations something that actually provides more value then making something like a parser which can do something similar? I was really happy with this question and I thought I would share it.
\\My response to Meghna:
\\So I am not sure if I have the correct answer but I can offer maybe one line of thinking. I think that to your first point it all depends on the implementation. Contracts are tricking pieces of legally binding paper and the dynamic nature of them might prove to be challenging to cover for the implementers of the DSL. To your second question I think of the European option as a separate entity from the American option and it makes more sense then them being related for the sake of uniqueness. 
\\My response to Andriana:
\\This is where I think it might speed up the process because once you have something that can be typed that has a strict set of rules the only thing that fallows is memorization which I think is a good trade off for the efficiency that one might acquire by picking up these skills.

\subsection{Week 12}
\\What is the invariant? Indicate the reasoning steps in which you apply the rules of Hoare Logic.
\\while (x!=0) do z:=z*y;  x:= x-1 done
\\We can write out our logic like:
\\{x>=0}while (x!=0) do z:=z*y;  x:= x-1 done
\\We can set the variables:
\\x = 100
\\y = 2
\\z = 1
\\We can also initialize a veriable t to 0 and use it to keep track of loop exuction.
\\With that we get:
\\t     x     y     z
\\0     100   2     1
\\1     99    2     2
\\2     98    2     4
\\...   ...   ...   ...
\\99    1     2     2^99
\\100   0     2     2^100
\\t + x = 100 ->
\\t = 100 - x
\\z = y^t
\\The invariant z = y^(100-x)


\section{Project}
Introductory remarks ...
Over the course of this last summer I got the opertunity to program in rust. I wasn't able to go really in depth but the functionality of the languge really caught my attention.
Rust has a lot of really interesting features making it feel like a modern version of C or C++ to me. What I set out to do with my project was 
show off the differences that sets rust apart from C and C++ in attempts to convince the reader that there are use cases where programming in rust is more valuable.

\subsection{Specification}
I decided for my project I am going to show off 3 main use cases for Rust and why you would want to use it instead of C. The first case will be 
the memory protection. The second case will be the compile and run time of similar systems. I will also 
\subsection{Prototype}
\subsection{Documentation}
\subsection{Critical Appraisal}
  
\ldots

\section{Conclusions}\label{conclusions}

(approx 400 words)

In the conclusion, I want a critical reflection on the content of the course. Step back from the technical details. How does the course fit into the wider world of programming languages and software engineering?

\begin{thebibliography}{99}
\bibitem[PL]{PL} \href{https://github.com/alexhkurz/programming-languages-2022/blob/main/README.md}{Programming Languages 2022}, Chapman University, 2022.
\end{thebibliography}

\end{document}
